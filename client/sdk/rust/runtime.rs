// This file is generated by rust-protobuf 2.18.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `runtime/runtime.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_0;

#[derive(PartialEq,Clone,Default)]
pub struct Service {
    // message fields
    pub name: ::std::string::String,
    pub version: ::std::string::String,
    pub source: ::std::string::String,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub status: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Service {
    fn default() -> &'a Service {
        <Service as ::protobuf::Message>::default_instance()
    }
}

impl Service {
    pub fn new() -> Service {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string version = 2;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string source = 3;


    pub fn get_source(&self) -> &str {
        &self.source
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        &mut self.source
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source, ::std::string::String::new())
    }

    // repeated .runtime.Service.MetadataEntry metadata = 4;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }

    // int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = v;
    }
}

impl ::protobuf::Message for Service {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.metadata);
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(5, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if !self.source.is_empty() {
            os.write_string(3, &self.source)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.metadata, os)?;
        if self.status != 0 {
            os.write_int32(5, self.status)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Service {
        Service::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Service| { &m.name },
                |m: &mut Service| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &Service| { &m.version },
                |m: &mut Service| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source",
                |m: &Service| { &m.source },
                |m: &mut Service| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &Service| { &m.metadata },
                |m: &mut Service| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &Service| { &m.status },
                |m: &mut Service| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Service>(
                "Service",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Service {
        static instance: ::protobuf::rt::LazyV2<Service> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Service::new)
    }
}

impl ::protobuf::Clear for Service {
    fn clear(&mut self) {
        self.name.clear();
        self.version.clear();
        self.source.clear();
        self.metadata.clear();
        self.status = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Service {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateOptions {
    // message fields
    pub command: ::protobuf::RepeatedField<::std::string::String>,
    pub args: ::protobuf::RepeatedField<::std::string::String>,
    pub env: ::protobuf::RepeatedField<::std::string::String>,
    pub output: ::std::string::String,
    pub field_type: ::std::string::String,
    pub image: ::std::string::String,
    pub namespace: ::std::string::String,
    pub secrets: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub entrypoint: ::std::string::String,
    pub volumes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateOptions {
    fn default() -> &'a CreateOptions {
        <CreateOptions as ::protobuf::Message>::default_instance()
    }
}

impl CreateOptions {
    pub fn new() -> CreateOptions {
        ::std::default::Default::default()
    }

    // repeated string command = 1;


    pub fn get_command(&self) -> &[::std::string::String] {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }

    // repeated string args = 2;


    pub fn get_args(&self) -> &[::std::string::String] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    // repeated string env = 3;


    pub fn get_env(&self) -> &[::std::string::String] {
        &self.env
    }
    pub fn clear_env(&mut self) {
        self.env.clear();
    }

    // Param is passed by value, moved
    pub fn set_env(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.env = v;
    }

    // Mutable pointer to the field.
    pub fn mut_env(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.env
    }

    // Take field
    pub fn take_env(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.env, ::protobuf::RepeatedField::new())
    }

    // string output = 4;


    pub fn get_output(&self) -> &str {
        &self.output
    }
    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: ::std::string::String) {
        self.output = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output(&mut self) -> &mut ::std::string::String {
        &mut self.output
    }

    // Take field
    pub fn take_output(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.output, ::std::string::String::new())
    }

    // string type = 5;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string image = 6;


    pub fn get_image(&self) -> &str {
        &self.image
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        &mut self.image
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image, ::std::string::String::new())
    }

    // string namespace = 7;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }

    // repeated .runtime.CreateOptions.SecretsEntry secrets = 8;


    pub fn get_secrets(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.secrets
    }
    pub fn clear_secrets(&mut self) {
        self.secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_secrets(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.secrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_secrets(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.secrets
    }

    // Take field
    pub fn take_secrets(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.secrets, ::std::collections::HashMap::new())
    }

    // string entrypoint = 9;


    pub fn get_entrypoint(&self) -> &str {
        &self.entrypoint
    }
    pub fn clear_entrypoint(&mut self) {
        self.entrypoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_entrypoint(&mut self, v: ::std::string::String) {
        self.entrypoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entrypoint(&mut self) -> &mut ::std::string::String {
        &mut self.entrypoint
    }

    // Take field
    pub fn take_entrypoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entrypoint, ::std::string::String::new())
    }

    // repeated .runtime.CreateOptions.VolumesEntry volumes = 10;


    pub fn get_volumes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.volumes
    }
    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.volumes, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for CreateOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.command)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.args)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.env)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.output)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.secrets)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entrypoint)?;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.volumes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.env {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.output.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.output);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.field_type);
        }
        if !self.image.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.image);
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.namespace);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.secrets);
        if !self.entrypoint.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.entrypoint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.volumes);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.command {
            os.write_string(1, &v)?;
        };
        for v in &self.args {
            os.write_string(2, &v)?;
        };
        for v in &self.env {
            os.write_string(3, &v)?;
        };
        if !self.output.is_empty() {
            os.write_string(4, &self.output)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(5, &self.field_type)?;
        }
        if !self.image.is_empty() {
            os.write_string(6, &self.image)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(7, &self.namespace)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.secrets, os)?;
        if !self.entrypoint.is_empty() {
            os.write_string(9, &self.entrypoint)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.volumes, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateOptions {
        CreateOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "command",
                |m: &CreateOptions| { &m.command },
                |m: &mut CreateOptions| { &mut m.command },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "args",
                |m: &CreateOptions| { &m.args },
                |m: &mut CreateOptions| { &mut m.args },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "env",
                |m: &CreateOptions| { &m.env },
                |m: &mut CreateOptions| { &mut m.env },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "output",
                |m: &CreateOptions| { &m.output },
                |m: &mut CreateOptions| { &mut m.output },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &CreateOptions| { &m.field_type },
                |m: &mut CreateOptions| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image",
                |m: &CreateOptions| { &m.image },
                |m: &mut CreateOptions| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &CreateOptions| { &m.namespace },
                |m: &mut CreateOptions| { &mut m.namespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "secrets",
                |m: &CreateOptions| { &m.secrets },
                |m: &mut CreateOptions| { &mut m.secrets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entrypoint",
                |m: &CreateOptions| { &m.entrypoint },
                |m: &mut CreateOptions| { &mut m.entrypoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "volumes",
                |m: &CreateOptions| { &m.volumes },
                |m: &mut CreateOptions| { &mut m.volumes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateOptions>(
                "CreateOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateOptions {
        static instance: ::protobuf::rt::LazyV2<CreateOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateOptions::new)
    }
}

impl ::protobuf::Clear for CreateOptions {
    fn clear(&mut self) {
        self.command.clear();
        self.args.clear();
        self.env.clear();
        self.output.clear();
        self.field_type.clear();
        self.image.clear();
        self.namespace.clear();
        self.secrets.clear();
        self.entrypoint.clear();
        self.volumes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateRequest {
    // message fields
    pub service: ::protobuf::SingularPtrField<Service>,
    pub options: ::protobuf::SingularPtrField<CreateOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateRequest {
    fn default() -> &'a CreateRequest {
        <CreateRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateRequest {
    pub fn new() -> CreateRequest {
        ::std::default::Default::default()
    }

    // .runtime.Service service = 1;


    pub fn get_service(&self) -> &Service {
        self.service.as_ref().unwrap_or_else(|| <Service as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: Service) {
        self.service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut Service {
        if self.service.is_none() {
            self.service.set_default();
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> Service {
        self.service.take().unwrap_or_else(|| Service::new())
    }

    // .runtime.CreateOptions options = 2;


    pub fn get_options(&self) -> &CreateOptions {
        self.options.as_ref().unwrap_or_else(|| <CreateOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: CreateOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut CreateOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> CreateOptions {
        self.options.take().unwrap_or_else(|| CreateOptions::new())
    }
}

impl ::protobuf::Message for CreateRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateRequest {
        CreateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                "service",
                |m: &CreateRequest| { &m.service },
                |m: &mut CreateRequest| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreateOptions>>(
                "options",
                |m: &CreateRequest| { &m.options },
                |m: &mut CreateRequest| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateRequest>(
                "CreateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateRequest {
        static instance: ::protobuf::rt::LazyV2<CreateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateRequest::new)
    }
}

impl ::protobuf::Clear for CreateRequest {
    fn clear(&mut self) {
        self.service.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateResponse {
    fn default() -> &'a CreateResponse {
        <CreateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateResponse {
    pub fn new() -> CreateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CreateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateResponse {
        CreateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateResponse>(
                "CreateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateResponse {
        static instance: ::protobuf::rt::LazyV2<CreateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateResponse::new)
    }
}

impl ::protobuf::Clear for CreateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadOptions {
    // message fields
    pub service: ::std::string::String,
    pub version: ::std::string::String,
    pub field_type: ::std::string::String,
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadOptions {
    fn default() -> &'a ReadOptions {
        <ReadOptions as ::protobuf::Message>::default_instance()
    }
}

impl ReadOptions {
    pub fn new() -> ReadOptions {
        ::std::default::Default::default()
    }

    // string service = 1;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // string version = 2;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string type = 3;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string namespace = 4;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReadOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field_type);
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(3, &self.field_type)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(4, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadOptions {
        ReadOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service",
                |m: &ReadOptions| { &m.service },
                |m: &mut ReadOptions| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &ReadOptions| { &m.version },
                |m: &mut ReadOptions| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &ReadOptions| { &m.field_type },
                |m: &mut ReadOptions| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &ReadOptions| { &m.namespace },
                |m: &mut ReadOptions| { &mut m.namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadOptions>(
                "ReadOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadOptions {
        static instance: ::protobuf::rt::LazyV2<ReadOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadOptions::new)
    }
}

impl ::protobuf::Clear for ReadOptions {
    fn clear(&mut self) {
        self.service.clear();
        self.version.clear();
        self.field_type.clear();
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadRequest {
    // message fields
    pub options: ::protobuf::SingularPtrField<ReadOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadRequest {
    fn default() -> &'a ReadRequest {
        <ReadRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReadRequest {
    pub fn new() -> ReadRequest {
        ::std::default::Default::default()
    }

    // .runtime.ReadOptions options = 1;


    pub fn get_options(&self) -> &ReadOptions {
        self.options.as_ref().unwrap_or_else(|| <ReadOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ReadOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut ReadOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> ReadOptions {
        self.options.take().unwrap_or_else(|| ReadOptions::new())
    }
}

impl ::protobuf::Message for ReadRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadRequest {
        ReadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadOptions>>(
                "options",
                |m: &ReadRequest| { &m.options },
                |m: &mut ReadRequest| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadRequest>(
                "ReadRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadRequest {
        static instance: ::protobuf::rt::LazyV2<ReadRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadRequest::new)
    }
}

impl ::protobuf::Clear for ReadRequest {
    fn clear(&mut self) {
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadResponse {
    // message fields
    pub services: ::protobuf::RepeatedField<Service>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadResponse {
    fn default() -> &'a ReadResponse {
        <ReadResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReadResponse {
    pub fn new() -> ReadResponse {
        ::std::default::Default::default()
    }

    // repeated .runtime.Service services = 1;


    pub fn get_services(&self) -> &[Service] {
        &self.services
    }
    pub fn clear_services(&mut self) {
        self.services.clear();
    }

    // Param is passed by value, moved
    pub fn set_services(&mut self, v: ::protobuf::RepeatedField<Service>) {
        self.services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_services(&mut self) -> &mut ::protobuf::RepeatedField<Service> {
        &mut self.services
    }

    // Take field
    pub fn take_services(&mut self) -> ::protobuf::RepeatedField<Service> {
        ::std::mem::replace(&mut self.services, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReadResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.services {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.services)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.services {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadResponse {
        ReadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                "services",
                |m: &ReadResponse| { &m.services },
                |m: &mut ReadResponse| { &mut m.services },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadResponse>(
                "ReadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadResponse {
        static instance: ::protobuf::rt::LazyV2<ReadResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadResponse::new)
    }
}

impl ::protobuf::Clear for ReadResponse {
    fn clear(&mut self) {
        self.services.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteOptions {
    // message fields
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteOptions {
    fn default() -> &'a DeleteOptions {
        <DeleteOptions as ::protobuf::Message>::default_instance()
    }
}

impl DeleteOptions {
    pub fn new() -> DeleteOptions {
        ::std::default::Default::default()
    }

    // string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteOptions {
        DeleteOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &DeleteOptions| { &m.namespace },
                |m: &mut DeleteOptions| { &mut m.namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteOptions>(
                "DeleteOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteOptions {
        static instance: ::protobuf::rt::LazyV2<DeleteOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteOptions::new)
    }
}

impl ::protobuf::Clear for DeleteOptions {
    fn clear(&mut self) {
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRequest {
    // message fields
    pub service: ::protobuf::SingularPtrField<Service>,
    pub options: ::protobuf::SingularPtrField<DeleteOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRequest {
    fn default() -> &'a DeleteRequest {
        <DeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRequest {
    pub fn new() -> DeleteRequest {
        ::std::default::Default::default()
    }

    // .runtime.Service service = 1;


    pub fn get_service(&self) -> &Service {
        self.service.as_ref().unwrap_or_else(|| <Service as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: Service) {
        self.service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut Service {
        if self.service.is_none() {
            self.service.set_default();
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> Service {
        self.service.take().unwrap_or_else(|| Service::new())
    }

    // .runtime.DeleteOptions options = 2;


    pub fn get_options(&self) -> &DeleteOptions {
        self.options.as_ref().unwrap_or_else(|| <DeleteOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: DeleteOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut DeleteOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> DeleteOptions {
        self.options.take().unwrap_or_else(|| DeleteOptions::new())
    }
}

impl ::protobuf::Message for DeleteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRequest {
        DeleteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                "service",
                |m: &DeleteRequest| { &m.service },
                |m: &mut DeleteRequest| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeleteOptions>>(
                "options",
                |m: &DeleteRequest| { &m.options },
                |m: &mut DeleteRequest| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteRequest>(
                "DeleteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteRequest::new)
    }
}

impl ::protobuf::Clear for DeleteRequest {
    fn clear(&mut self) {
        self.service.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteResponse {
    fn default() -> &'a DeleteResponse {
        <DeleteResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteResponse {
    pub fn new() -> DeleteResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteResponse {
        DeleteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteResponse>(
                "DeleteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteResponse::new)
    }
}

impl ::protobuf::Clear for DeleteResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateOptions {
    // message fields
    pub namespace: ::std::string::String,
    pub entrypoint: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateOptions {
    fn default() -> &'a UpdateOptions {
        <UpdateOptions as ::protobuf::Message>::default_instance()
    }
}

impl UpdateOptions {
    pub fn new() -> UpdateOptions {
        ::std::default::Default::default()
    }

    // string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }

    // string entrypoint = 2;


    pub fn get_entrypoint(&self) -> &str {
        &self.entrypoint
    }
    pub fn clear_entrypoint(&mut self) {
        self.entrypoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_entrypoint(&mut self, v: ::std::string::String) {
        self.entrypoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entrypoint(&mut self) -> &mut ::std::string::String {
        &mut self.entrypoint
    }

    // Take field
    pub fn take_entrypoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entrypoint, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entrypoint)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        if !self.entrypoint.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entrypoint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        if !self.entrypoint.is_empty() {
            os.write_string(2, &self.entrypoint)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateOptions {
        UpdateOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &UpdateOptions| { &m.namespace },
                |m: &mut UpdateOptions| { &mut m.namespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entrypoint",
                |m: &UpdateOptions| { &m.entrypoint },
                |m: &mut UpdateOptions| { &mut m.entrypoint },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateOptions>(
                "UpdateOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateOptions {
        static instance: ::protobuf::rt::LazyV2<UpdateOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateOptions::new)
    }
}

impl ::protobuf::Clear for UpdateOptions {
    fn clear(&mut self) {
        self.namespace.clear();
        self.entrypoint.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateRequest {
    // message fields
    pub service: ::protobuf::SingularPtrField<Service>,
    pub options: ::protobuf::SingularPtrField<UpdateOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateRequest {
    fn default() -> &'a UpdateRequest {
        <UpdateRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateRequest {
    pub fn new() -> UpdateRequest {
        ::std::default::Default::default()
    }

    // .runtime.Service service = 1;


    pub fn get_service(&self) -> &Service {
        self.service.as_ref().unwrap_or_else(|| <Service as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: Service) {
        self.service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut Service {
        if self.service.is_none() {
            self.service.set_default();
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> Service {
        self.service.take().unwrap_or_else(|| Service::new())
    }

    // .runtime.UpdateOptions options = 2;


    pub fn get_options(&self) -> &UpdateOptions {
        self.options.as_ref().unwrap_or_else(|| <UpdateOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: UpdateOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut UpdateOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> UpdateOptions {
        self.options.take().unwrap_or_else(|| UpdateOptions::new())
    }
}

impl ::protobuf::Message for UpdateRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateRequest {
        UpdateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                "service",
                |m: &UpdateRequest| { &m.service },
                |m: &mut UpdateRequest| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateOptions>>(
                "options",
                |m: &UpdateRequest| { &m.options },
                |m: &mut UpdateRequest| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateRequest>(
                "UpdateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateRequest::new)
    }
}

impl ::protobuf::Clear for UpdateRequest {
    fn clear(&mut self) {
        self.service.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateResponse {
    fn default() -> &'a UpdateResponse {
        <UpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateResponse {
    pub fn new() -> UpdateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateResponse {
        UpdateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateResponse>(
                "UpdateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateResponse::new)
    }
}

impl ::protobuf::Clear for UpdateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOptions {
    // message fields
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOptions {
    fn default() -> &'a ListOptions {
        <ListOptions as ::protobuf::Message>::default_instance()
    }
}

impl ListOptions {
    pub fn new() -> ListOptions {
        ::std::default::Default::default()
    }

    // string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOptions {
        ListOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &ListOptions| { &m.namespace },
                |m: &mut ListOptions| { &mut m.namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOptions>(
                "ListOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOptions {
        static instance: ::protobuf::rt::LazyV2<ListOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOptions::new)
    }
}

impl ::protobuf::Clear for ListOptions {
    fn clear(&mut self) {
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListRequest {
    // message fields
    pub options: ::protobuf::SingularPtrField<ListOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListRequest {
    fn default() -> &'a ListRequest {
        <ListRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRequest {
    pub fn new() -> ListRequest {
        ::std::default::Default::default()
    }

    // .runtime.ListOptions options = 1;


    pub fn get_options(&self) -> &ListOptions {
        self.options.as_ref().unwrap_or_else(|| <ListOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ListOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut ListOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> ListOptions {
        self.options.take().unwrap_or_else(|| ListOptions::new())
    }
}

impl ::protobuf::Message for ListRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListRequest {
        ListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListOptions>>(
                "options",
                |m: &ListRequest| { &m.options },
                |m: &mut ListRequest| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListRequest>(
                "ListRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListRequest {
        static instance: ::protobuf::rt::LazyV2<ListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListRequest::new)
    }
}

impl ::protobuf::Clear for ListRequest {
    fn clear(&mut self) {
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListResponse {
    // message fields
    pub services: ::protobuf::RepeatedField<Service>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListResponse {
    fn default() -> &'a ListResponse {
        <ListResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListResponse {
    pub fn new() -> ListResponse {
        ::std::default::Default::default()
    }

    // repeated .runtime.Service services = 1;


    pub fn get_services(&self) -> &[Service] {
        &self.services
    }
    pub fn clear_services(&mut self) {
        self.services.clear();
    }

    // Param is passed by value, moved
    pub fn set_services(&mut self, v: ::protobuf::RepeatedField<Service>) {
        self.services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_services(&mut self) -> &mut ::protobuf::RepeatedField<Service> {
        &mut self.services
    }

    // Take field
    pub fn take_services(&mut self) -> ::protobuf::RepeatedField<Service> {
        ::std::mem::replace(&mut self.services, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.services {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.services)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.services {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListResponse {
        ListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                "services",
                |m: &ListResponse| { &m.services },
                |m: &mut ListResponse| { &mut m.services },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListResponse>(
                "ListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListResponse {
        static instance: ::protobuf::rt::LazyV2<ListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListResponse::new)
    }
}

impl ::protobuf::Clear for ListResponse {
    fn clear(&mut self) {
        self.services.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogsOptions {
    // message fields
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogsOptions {
    fn default() -> &'a LogsOptions {
        <LogsOptions as ::protobuf::Message>::default_instance()
    }
}

impl LogsOptions {
    pub fn new() -> LogsOptions {
        ::std::default::Default::default()
    }

    // string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LogsOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogsOptions {
        LogsOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &LogsOptions| { &m.namespace },
                |m: &mut LogsOptions| { &mut m.namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogsOptions>(
                "LogsOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogsOptions {
        static instance: ::protobuf::rt::LazyV2<LogsOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogsOptions::new)
    }
}

impl ::protobuf::Clear for LogsOptions {
    fn clear(&mut self) {
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogsOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogsOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogsRequest {
    // message fields
    pub service: ::std::string::String,
    pub stream: bool,
    pub count: i64,
    pub since: i64,
    pub options: ::protobuf::SingularPtrField<LogsOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogsRequest {
    fn default() -> &'a LogsRequest {
        <LogsRequest as ::protobuf::Message>::default_instance()
    }
}

impl LogsRequest {
    pub fn new() -> LogsRequest {
        ::std::default::Default::default()
    }

    // string service = 1;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // bool stream = 2;


    pub fn get_stream(&self) -> bool {
        self.stream
    }
    pub fn clear_stream(&mut self) {
        self.stream = false;
    }

    // Param is passed by value, moved
    pub fn set_stream(&mut self, v: bool) {
        self.stream = v;
    }

    // int64 count = 3;


    pub fn get_count(&self) -> i64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i64) {
        self.count = v;
    }

    // int64 since = 4;


    pub fn get_since(&self) -> i64 {
        self.since
    }
    pub fn clear_since(&mut self) {
        self.since = 0;
    }

    // Param is passed by value, moved
    pub fn set_since(&mut self, v: i64) {
        self.since = v;
    }

    // .runtime.LogsOptions options = 5;


    pub fn get_options(&self) -> &LogsOptions {
        self.options.as_ref().unwrap_or_else(|| <LogsOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: LogsOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut LogsOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> LogsOptions {
        self.options.take().unwrap_or_else(|| LogsOptions::new())
    }
}

impl ::protobuf::Message for LogsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stream = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.count = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.since = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        if self.stream != false {
            my_size += 2;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.since != 0 {
            my_size += ::protobuf::rt::value_size(4, self.since, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        if self.stream != false {
            os.write_bool(2, self.stream)?;
        }
        if self.count != 0 {
            os.write_int64(3, self.count)?;
        }
        if self.since != 0 {
            os.write_int64(4, self.since)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogsRequest {
        LogsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service",
                |m: &LogsRequest| { &m.service },
                |m: &mut LogsRequest| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stream",
                |m: &LogsRequest| { &m.stream },
                |m: &mut LogsRequest| { &mut m.stream },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "count",
                |m: &LogsRequest| { &m.count },
                |m: &mut LogsRequest| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "since",
                |m: &LogsRequest| { &m.since },
                |m: &mut LogsRequest| { &mut m.since },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogsOptions>>(
                "options",
                |m: &LogsRequest| { &m.options },
                |m: &mut LogsRequest| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogsRequest>(
                "LogsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogsRequest {
        static instance: ::protobuf::rt::LazyV2<LogsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogsRequest::new)
    }
}

impl ::protobuf::Clear for LogsRequest {
    fn clear(&mut self) {
        self.service.clear();
        self.stream = false;
        self.count = 0;
        self.since = 0;
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogRecord {
    // message fields
    pub timestamp: i64,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogRecord {
    fn default() -> &'a LogRecord {
        <LogRecord as ::protobuf::Message>::default_instance()
    }
}

impl LogRecord {
    pub fn new() -> LogRecord {
        ::std::default::Default::default()
    }

    // int64 timestamp = 1;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // repeated .runtime.LogRecord.MetadataEntry metadata = 2;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LogRecord {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.metadata);
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_int64(1, self.timestamp)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.metadata, os)?;
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogRecord {
        LogRecord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &LogRecord| { &m.timestamp },
                |m: &mut LogRecord| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &LogRecord| { &m.metadata },
                |m: &mut LogRecord| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &LogRecord| { &m.message },
                |m: &mut LogRecord| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogRecord>(
                "LogRecord",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogRecord {
        static instance: ::protobuf::rt::LazyV2<LogRecord> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogRecord::new)
    }
}

impl ::protobuf::Clear for LogRecord {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.metadata.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateNamespaceRequest {
    // message fields
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateNamespaceRequest {
    fn default() -> &'a CreateNamespaceRequest {
        <CreateNamespaceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateNamespaceRequest {
    pub fn new() -> CreateNamespaceRequest {
        ::std::default::Default::default()
    }

    // string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateNamespaceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateNamespaceRequest {
        CreateNamespaceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &CreateNamespaceRequest| { &m.namespace },
                |m: &mut CreateNamespaceRequest| { &mut m.namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateNamespaceRequest>(
                "CreateNamespaceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateNamespaceRequest {
        static instance: ::protobuf::rt::LazyV2<CreateNamespaceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateNamespaceRequest::new)
    }
}

impl ::protobuf::Clear for CreateNamespaceRequest {
    fn clear(&mut self) {
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateNamespaceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateNamespaceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateNamespaceResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateNamespaceResponse {
    fn default() -> &'a CreateNamespaceResponse {
        <CreateNamespaceResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateNamespaceResponse {
    pub fn new() -> CreateNamespaceResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CreateNamespaceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateNamespaceResponse {
        CreateNamespaceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateNamespaceResponse>(
                "CreateNamespaceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateNamespaceResponse {
        static instance: ::protobuf::rt::LazyV2<CreateNamespaceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateNamespaceResponse::new)
    }
}

impl ::protobuf::Clear for CreateNamespaceResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateNamespaceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateNamespaceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteNamespaceRequest {
    // message fields
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteNamespaceRequest {
    fn default() -> &'a DeleteNamespaceRequest {
        <DeleteNamespaceRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteNamespaceRequest {
    pub fn new() -> DeleteNamespaceRequest {
        ::std::default::Default::default()
    }

    // string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteNamespaceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteNamespaceRequest {
        DeleteNamespaceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &DeleteNamespaceRequest| { &m.namespace },
                |m: &mut DeleteNamespaceRequest| { &mut m.namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteNamespaceRequest>(
                "DeleteNamespaceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteNamespaceRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteNamespaceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteNamespaceRequest::new)
    }
}

impl ::protobuf::Clear for DeleteNamespaceRequest {
    fn clear(&mut self) {
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteNamespaceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteNamespaceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteNamespaceResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteNamespaceResponse {
    fn default() -> &'a DeleteNamespaceResponse {
        <DeleteNamespaceResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteNamespaceResponse {
    pub fn new() -> DeleteNamespaceResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteNamespaceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteNamespaceResponse {
        DeleteNamespaceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteNamespaceResponse>(
                "DeleteNamespaceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteNamespaceResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteNamespaceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteNamespaceResponse::new)
    }
}

impl ::protobuf::Clear for DeleteNamespaceResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteNamespaceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteNamespaceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UploadRequest {
    // message fields
    pub service: ::protobuf::SingularPtrField<Service>,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UploadRequest {
    fn default() -> &'a UploadRequest {
        <UploadRequest as ::protobuf::Message>::default_instance()
    }
}

impl UploadRequest {
    pub fn new() -> UploadRequest {
        ::std::default::Default::default()
    }

    // .runtime.Service service = 1;


    pub fn get_service(&self) -> &Service {
        self.service.as_ref().unwrap_or_else(|| <Service as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: Service) {
        self.service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut Service {
        if self.service.is_none() {
            self.service.set_default();
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> Service {
        self.service.take().unwrap_or_else(|| Service::new())
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UploadRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UploadRequest {
        UploadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                "service",
                |m: &UploadRequest| { &m.service },
                |m: &mut UploadRequest| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &UploadRequest| { &m.data },
                |m: &mut UploadRequest| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UploadRequest>(
                "UploadRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UploadRequest {
        static instance: ::protobuf::rt::LazyV2<UploadRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UploadRequest::new)
    }
}

impl ::protobuf::Clear for UploadRequest {
    fn clear(&mut self) {
        self.service.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UploadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UploadResponse {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UploadResponse {
    fn default() -> &'a UploadResponse {
        <UploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl UploadResponse {
    pub fn new() -> UploadResponse {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UploadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UploadResponse {
        UploadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &UploadResponse| { &m.id },
                |m: &mut UploadResponse| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UploadResponse>(
                "UploadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UploadResponse {
        static instance: ::protobuf::rt::LazyV2<UploadResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UploadResponse::new)
    }
}

impl ::protobuf::Clear for UploadResponse {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuildReadResponse {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildReadResponse {
    fn default() -> &'a BuildReadResponse {
        <BuildReadResponse as ::protobuf::Message>::default_instance()
    }
}

impl BuildReadResponse {
    pub fn new() -> BuildReadResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BuildReadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildReadResponse {
        BuildReadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &BuildReadResponse| { &m.data },
                |m: &mut BuildReadResponse| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildReadResponse>(
                "BuildReadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildReadResponse {
        static instance: ::protobuf::rt::LazyV2<BuildReadResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildReadResponse::new)
    }
}

impl ::protobuf::Clear for BuildReadResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildReadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildReadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15runtime/runtime.proto\x12\x07runtime\"\xe0\x01\n\x07Service\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07version\x18\x02\
    \x20\x01(\tR\x07version\x12\x16\n\x06source\x18\x03\x20\x01(\tR\x06sourc\
    e\x12:\n\x08metadata\x18\x04\x20\x03(\x0b2\x1e.runtime.Service.MetadataE\
    ntryR\x08metadata\x12\x16\n\x06status\x18\x05\x20\x01(\x05R\x06status\
    \x1a;\n\rMetadataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xc5\x03\n\rCrea\
    teOptions\x12\x18\n\x07command\x18\x01\x20\x03(\tR\x07command\x12\x12\n\
    \x04args\x18\x02\x20\x03(\tR\x04args\x12\x10\n\x03env\x18\x03\x20\x03(\t\
    R\x03env\x12\x16\n\x06output\x18\x04\x20\x01(\tR\x06output\x12\x12\n\x04\
    type\x18\x05\x20\x01(\tR\x04type\x12\x14\n\x05image\x18\x06\x20\x01(\tR\
    \x05image\x12\x1c\n\tnamespace\x18\x07\x20\x01(\tR\tnamespace\x12=\n\x07\
    secrets\x18\x08\x20\x03(\x0b2#.runtime.CreateOptions.SecretsEntryR\x07se\
    crets\x12\x1e\n\nentrypoint\x18\t\x20\x01(\tR\nentrypoint\x12=\n\x07volu\
    mes\x18\n\x20\x03(\x0b2#.runtime.CreateOptions.VolumesEntryR\x07volumes\
    \x1a:\n\x0cSecretsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a:\n\x0cVolumes\
    Entry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"m\n\rCreateRequest\x12*\n\x07servic\
    e\x18\x01\x20\x01(\x0b2\x10.runtime.ServiceR\x07service\x120\n\x07option\
    s\x18\x02\x20\x01(\x0b2\x16.runtime.CreateOptionsR\x07options\"\x10\n\
    \x0eCreateResponse\"s\n\x0bReadOptions\x12\x18\n\x07service\x18\x01\x20\
    \x01(\tR\x07service\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07version\
    \x12\x12\n\x04type\x18\x03\x20\x01(\tR\x04type\x12\x1c\n\tnamespace\x18\
    \x04\x20\x01(\tR\tnamespace\"=\n\x0bReadRequest\x12.\n\x07options\x18\
    \x01\x20\x01(\x0b2\x14.runtime.ReadOptionsR\x07options\"<\n\x0cReadRespo\
    nse\x12,\n\x08services\x18\x01\x20\x03(\x0b2\x10.runtime.ServiceR\x08ser\
    vices\"-\n\rDeleteOptions\x12\x1c\n\tnamespace\x18\x01\x20\x01(\tR\tname\
    space\"m\n\rDeleteRequest\x12*\n\x07service\x18\x01\x20\x01(\x0b2\x10.ru\
    ntime.ServiceR\x07service\x120\n\x07options\x18\x02\x20\x01(\x0b2\x16.ru\
    ntime.DeleteOptionsR\x07options\"\x10\n\x0eDeleteResponse\"M\n\rUpdateOp\
    tions\x12\x1c\n\tnamespace\x18\x01\x20\x01(\tR\tnamespace\x12\x1e\n\nent\
    rypoint\x18\x02\x20\x01(\tR\nentrypoint\"m\n\rUpdateRequest\x12*\n\x07se\
    rvice\x18\x01\x20\x01(\x0b2\x10.runtime.ServiceR\x07service\x120\n\x07op\
    tions\x18\x02\x20\x01(\x0b2\x16.runtime.UpdateOptionsR\x07options\"\x10\
    \n\x0eUpdateResponse\"+\n\x0bListOptions\x12\x1c\n\tnamespace\x18\x01\
    \x20\x01(\tR\tnamespace\"=\n\x0bListRequest\x12.\n\x07options\x18\x01\
    \x20\x01(\x0b2\x14.runtime.ListOptionsR\x07options\"<\n\x0cListResponse\
    \x12,\n\x08services\x18\x01\x20\x03(\x0b2\x10.runtime.ServiceR\x08servic\
    es\"+\n\x0bLogsOptions\x12\x1c\n\tnamespace\x18\x01\x20\x01(\tR\tnamespa\
    ce\"\x9b\x01\n\x0bLogsRequest\x12\x18\n\x07service\x18\x01\x20\x01(\tR\
    \x07service\x12\x16\n\x06stream\x18\x02\x20\x01(\x08R\x06stream\x12\x14\
    \n\x05count\x18\x03\x20\x01(\x03R\x05count\x12\x14\n\x05since\x18\x04\
    \x20\x01(\x03R\x05since\x12.\n\x07options\x18\x05\x20\x01(\x0b2\x14.runt\
    ime.LogsOptionsR\x07options\"\xbe\x01\n\tLogRecord\x12\x1c\n\ttimestamp\
    \x18\x01\x20\x01(\x03R\ttimestamp\x12<\n\x08metadata\x18\x02\x20\x03(\
    \x0b2\x20.runtime.LogRecord.MetadataEntryR\x08metadata\x12\x18\n\x07mess\
    age\x18\x03\x20\x01(\tR\x07message\x1a;\n\rMetadataEntry\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05v\
    alue:\x028\x01\"6\n\x16CreateNamespaceRequest\x12\x1c\n\tnamespace\x18\
    \x01\x20\x01(\tR\tnamespace\"\x19\n\x17CreateNamespaceResponse\"6\n\x16D\
    eleteNamespaceRequest\x12\x1c\n\tnamespace\x18\x01\x20\x01(\tR\tnamespac\
    e\"\x19\n\x17DeleteNamespaceResponse\"O\n\rUploadRequest\x12*\n\x07servi\
    ce\x18\x01\x20\x01(\x0b2\x10.runtime.ServiceR\x07service\x12\x12\n\x04da\
    ta\x18\x02\x20\x01(\x0cR\x04data\"\x20\n\x0eUploadResponse\x12\x0e\n\x02\
    id\x18\x01\x20\x01(\tR\x02id\"'\n\x11BuildReadResponse\x12\x12\n\x04data\
    \x18\x01\x20\x01(\x0cR\x04data2\xdd\x03\n\x07Runtime\x12;\n\x06Create\
    \x12\x16.runtime.CreateRequest\x1a\x17.runtime.CreateResponse\"\0\x125\n\
    \x04Read\x12\x14.runtime.ReadRequest\x1a\x15.runtime.ReadResponse\"\0\
    \x12;\n\x06Delete\x12\x16.runtime.DeleteRequest\x1a\x17.runtime.DeleteRe\
    sponse\"\0\x12;\n\x06Update\x12\x16.runtime.UpdateRequest\x1a\x17.runtim\
    e.UpdateResponse\"\0\x124\n\x04Logs\x12\x14.runtime.LogsRequest\x1a\x12.\
    runtime.LogRecord\"\00\x01\x12V\n\x0fCreateNamespace\x12\x1f.runtime.Cre\
    ateNamespaceRequest\x1a\x20.runtime.CreateNamespaceResponse\"\0\x12V\n\
    \x0fDeleteNamespace\x12\x1f.runtime.DeleteNamespaceRequest\x1a\x20.runti\
    me.DeleteNamespaceResponse\"\02G\n\x06Source\x12=\n\x06Upload\x12\x16.ru\
    ntime.UploadRequest\x1a\x17.runtime.UploadResponse\"\0(\x012A\n\x05Build\
    \x128\n\x04Read\x12\x10.runtime.Service\x1a\x1a.runtime.BuildReadRespons\
    e\"\00\x01B1Z/github.com/micro/micro/v3/proto/runtime;runtimeJ\xa00\n\
    \x07\x12\x05\0\0\xb9\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\
    \x02\x12\x03\x02\x08\x0f\n\x08\n\x01\x08\x12\x03\x04\0F\n\t\n\x02\x08\
    \x0b\x12\x03\x04\0F\n\n\n\x02\x06\0\x12\x04\x06\0\x0e\x01\n\n\n\x03\x06\
    \0\x01\x12\x03\x06\x08\x0f\n\x0b\n\x04\x06\0\x02\0\x12\x03\x07\x08=\n\
    \x0c\n\x05\x06\0\x02\0\x01\x12\x03\x07\x0c\x12\n\x0c\n\x05\x06\0\x02\0\
    \x02\x12\x03\x07\x13\x20\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x07+9\n\x0b\
    \n\x04\x06\0\x02\x01\x12\x03\x08\x087\n\x0c\n\x05\x06\0\x02\x01\x01\x12\
    \x03\x08\x0c\x10\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x08\x11\x1c\n\x0c\
    \n\x05\x06\0\x02\x01\x03\x12\x03\x08'3\n\x0b\n\x04\x06\0\x02\x02\x12\x03\
    \t\x08=\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\t\x0c\x12\n\x0c\n\x05\x06\
    \0\x02\x02\x02\x12\x03\t\x13\x20\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\t\
    +9\n\x0b\n\x04\x06\0\x02\x03\x12\x03\n\x08=\n\x0c\n\x05\x06\0\x02\x03\
    \x01\x12\x03\n\x0c\x12\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\n\x13\x20\n\
    \x0c\n\x05\x06\0\x02\x03\x03\x12\x03\n+9\n\x0b\n\x04\x06\0\x02\x04\x12\
    \x03\x0b\x08;\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03\x0b\x0c\x10\n\x0c\n\
    \x05\x06\0\x02\x04\x02\x12\x03\x0b\x11\x1c\n\x0c\n\x05\x06\0\x02\x04\x06\
    \x12\x03\x0b'-\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03\x0b.7\n\x0b\n\x04\
    \x06\0\x02\x05\x12\x03\x0c\x08X\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03\
    \x0c\x0c\x1b\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03\x0c\x1c2\n\x0c\n\x05\
    \x06\0\x02\x05\x03\x12\x03\x0c=T\n\x0b\n\x04\x06\0\x02\x06\x12\x03\r\x08\
    X\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03\r\x0c\x1b\n\x0c\n\x05\x06\0\x02\
    \x06\x02\x12\x03\r\x1c2\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03\r=T\n\xa4\
    \x02\n\x02\x06\x01\x12\x04\x13\0\x15\x01\x1a\x97\x02\x20Source\x20servic\
    e\x20is\x20used\x20by\x20the\x20CLI\x20to\x20upload\x20source\x20to\x20t\
    he\x20service.\x20The\x20service\x20will\x20return\n\x20a\x20unique\x20I\
    D\x20representing\x20the\x20location\x20of\x20that\x20source.\x20This\
    \x20ID\x20can\x20then\x20be\x20used\x20as\x20a\x20source\n\x20for\x20the\
    \x20service\x20when\x20doing\x20Runtime.Create.\x20The\x20server\x20will\
    \x20handle\x20cleanup\x20of\x20uploaded\x20source.\n\n\n\n\x03\x06\x01\
    \x01\x12\x03\x13\x08\x0e\n\x0b\n\x04\x06\x01\x02\0\x12\x03\x14\x08D\n\
    \x0c\n\x05\x06\x01\x02\0\x01\x12\x03\x14\x0c\x12\n\x0c\n\x05\x06\x01\x02\
    \0\x05\x12\x03\x14\x13\x19\n\x0c\n\x05\x06\x01\x02\0\x02\x12\x03\x14\x1a\
    '\n\x0c\n\x05\x06\x01\x02\0\x03\x12\x03\x142@\n\xe1\x01\n\x02\x06\x02\
    \x12\x04\x1a\0\x1c\x01\x1a\xd4\x01\x20Build\x20service\x20is\x20used\x20\
    by\x20containers\x20to\x20download\x20prebuilt\x20binaries.\x20The\x20cl\
    ient\x20will\x20pass\x20the\x20\n\x20service\x20(name\x20and\x20version\
    \x20are\x20required\x20attributed)\x20and\x20the\x20server\x20will\x20th\
    en\x20stream\x20the\x20latest\n\x20binary\x20to\x20the\x20client.\n\n\n\
    \n\x03\x06\x02\x01\x12\x03\x1a\x08\r\n\x0b\n\x04\x06\x02\x02\0\x12\x03\
    \x1b\x08?\n\x0c\n\x05\x06\x02\x02\0\x01\x12\x03\x1b\x0c\x10\n\x0c\n\x05\
    \x06\x02\x02\0\x02\x12\x03\x1b\x11\x18\n\x0c\n\x05\x06\x02\x02\0\x06\x12\
    \x03\x1b#)\n\x0c\n\x05\x06\x02\x02\0\x03\x12\x03\x1b*;\n\n\n\x02\x04\0\
    \x12\x04\x1e\0)\x01\n\n\n\x03\x04\0\x01\x12\x03\x1e\x08\x0f\n\"\n\x04\
    \x04\0\x02\0\x12\x03\x20\x08\x18\x1a\x15\x20name\x20of\x20the\x20service\
    \n\n\r\n\x05\x04\0\x02\0\x04\x12\x04\x20\x08\x1e\x11\n\x0c\n\x05\x04\0\
    \x02\0\x05\x12\x03\x20\x08\x0e\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x20\
    \x0f\x13\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x20\x16\x17\n%\n\x04\x04\0\
    \x02\x01\x12\x03\"\x08\x1b\x1a\x18\x20version\x20of\x20the\x20service\n\
    \n\r\n\x05\x04\0\x02\x01\x04\x12\x04\"\x08\x20\x18\n\x0c\n\x05\x04\0\x02\
    \x01\x05\x12\x03\"\x08\x0e\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\"\x0f\
    \x16\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\"\x19\x1a\n$\n\x04\x04\0\x02\
    \x02\x12\x03$\x08\x1a\x1a\x17\x20git\x20url\x20of\x20the\x20source\n\n\r\
    \n\x05\x04\0\x02\x02\x04\x12\x04$\x08\"\x1b\n\x0c\n\x05\x04\0\x02\x02\
    \x05\x12\x03$\x08\x0e\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03$\x0f\x15\n\
    \x0c\n\x05\x04\0\x02\x02\x03\x12\x03$\x18\x19\n\x1f\n\x04\x04\0\x02\x03\
    \x12\x03&\x08(\x1a\x12\x20service\x20metadata\n\n\r\n\x05\x04\0\x02\x03\
    \x04\x12\x04&\x08$\x1a\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03&\x08\x1a\n\
    \x0c\n\x05\x04\0\x02\x03\x01\x12\x03&\x1b#\n\x0c\n\x05\x04\0\x02\x03\x03\
    \x12\x03&&'\n$\n\x04\x04\0\x02\x04\x12\x03(\x08\x19\x1a\x17\x20status\
    \x20of\x20the\x20service\n\n\r\n\x05\x04\0\x02\x04\x04\x12\x04(\x08&(\n\
    \x0c\n\x05\x04\0\x02\x04\x05\x12\x03(\x08\r\n\x0c\n\x05\x04\0\x02\x04\
    \x01\x12\x03(\x0e\x14\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03(\x17\x18\n\n\
    \n\x02\x04\x01\x12\x04+\0@\x01\n\n\n\x03\x04\x01\x01\x12\x03+\x08\x15\n!\
    \n\x04\x04\x01\x02\0\x12\x03-\x08$\x1a\x14\x20command\x20to\x20pass\x20i\
    n\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03-\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03-\x11\x17\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03-\x18\
    \x1f\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03-\"#\n(\n\x04\x04\x01\x02\x01\
    \x12\x03/\x08!\x1a\x1b\x20args\x20to\x20pass\x20into\x20command\n\n\x0c\
    \n\x05\x04\x01\x02\x01\x04\x12\x03/\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\
    \x05\x12\x03/\x11\x17\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03/\x18\x1c\n\
    \x0c\n\x05\x04\x01\x02\x01\x03\x12\x03/\x1f\x20\n%\n\x04\x04\x01\x02\x02\
    \x12\x031\x08\x20\x1a\x18\x20environment\x20to\x20pass\x20in\n\n\x0c\n\
    \x05\x04\x01\x02\x02\x04\x12\x031\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\
    \x05\x12\x031\x11\x17\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x031\x18\x1b\n\
    \x0c\n\x05\x04\x01\x02\x02\x03\x12\x031\x1e\x1f\n\x20\n\x04\x04\x01\x02\
    \x03\x12\x033\x08\x1a\x1a\x13\x20output\x20to\x20send\x20to\n\n\r\n\x05\
    \x04\x01\x02\x03\x04\x12\x043\x081\x20\n\x0c\n\x05\x04\x01\x02\x03\x05\
    \x12\x033\x08\x0e\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x033\x0f\x15\n\x0c\
    \n\x05\x04\x01\x02\x03\x03\x12\x033\x18\x19\n%\n\x04\x04\x01\x02\x04\x12\
    \x035\x08\x18\x1a\x18\x20create\x20type\x20of\x20service\n\n\r\n\x05\x04\
    \x01\x02\x04\x04\x12\x045\x083\x1a\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\
    \x035\x08\x0e\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x035\x0f\x13\n\x0c\n\
    \x05\x04\x01\x02\x04\x03\x12\x035\x16\x17\n\x1b\n\x04\x04\x01\x02\x05\
    \x12\x037\x08\x19\x1a\x0e\x20image\x20to\x20use\n\n\r\n\x05\x04\x01\x02\
    \x05\x04\x12\x047\x085\x18\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x037\x08\
    \x0e\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x037\x0f\x14\n\x0c\n\x05\x04\
    \x01\x02\x05\x03\x12\x037\x17\x18\n1\n\x04\x04\x01\x02\x06\x12\x039\x08\
    \x1d\x1a$\x20namespace\x20to\x20create\x20the\x20service\x20in\n\n\r\n\
    \x05\x04\x01\x02\x06\x04\x12\x049\x087\x19\n\x0c\n\x05\x04\x01\x02\x06\
    \x05\x12\x039\x08\x0e\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x039\x0f\x18\n\
    \x0c\n\x05\x04\x01\x02\x06\x03\x12\x039\x1b\x1c\n-\n\x04\x04\x01\x02\x07\
    \x12\x03;\x08'\x1a\x20\x20secrets\x20to\x20use\x20for\x20the\x20service\
    \n\n\r\n\x05\x04\x01\x02\x07\x04\x12\x04;\x089\x1d\n\x0c\n\x05\x04\x01\
    \x02\x07\x06\x12\x03;\x08\x1a\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x03;\
    \x1b\"\n\x0c\n\x05\x04\x01\x02\x07\x03\x12\x03;%&\n+\n\x04\x04\x01\x02\
    \x08\x12\x03=\x08\x1e\x1a\x1e\x20entrypoint\x20within\x20the\x20source\n\
    \n\r\n\x05\x04\x01\x02\x08\x04\x12\x04=\x08;'\n\x0c\n\x05\x04\x01\x02\
    \x08\x05\x12\x03=\x08\x0e\n\x0c\n\x05\x04\x01\x02\x08\x01\x12\x03=\x0f\
    \x19\n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x03=\x1c\x1d\n\x1f\n\x04\x04\
    \x01\x02\t\x12\x03?\x08(\x1a\x12\x20volumes\x20to\x20mount\n\n\r\n\x05\
    \x04\x01\x02\t\x04\x12\x04?\x08=\x1e\n\x0c\n\x05\x04\x01\x02\t\x06\x12\
    \x03?\x08\x1a\n\x0c\n\x05\x04\x01\x02\t\x01\x12\x03?\x1b\"\n\x0c\n\x05\
    \x04\x01\x02\t\x03\x12\x03?%'\n\n\n\x02\x04\x02\x12\x04B\0E\x01\n\n\n\
    \x03\x04\x02\x01\x12\x03B\x08\x15\n\x0b\n\x04\x04\x02\x02\0\x12\x03C\x08\
    \x1c\n\r\n\x05\x04\x02\x02\0\x04\x12\x04C\x08B\x17\n\x0c\n\x05\x04\x02\
    \x02\0\x06\x12\x03C\x08\x0f\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03C\x10\
    \x17\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03C\x1a\x1b\n\x0b\n\x04\x04\x02\
    \x02\x01\x12\x03D\x08\"\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04D\x08C\x1c\
    \n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x03D\x08\x15\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03D\x16\x1d\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03D\
    \x20!\n\t\n\x02\x04\x03\x12\x03G\0\x19\n\n\n\x03\x04\x03\x01\x12\x03G\
    \x08\x16\n\n\n\x02\x04\x04\x12\x04I\0R\x01\n\n\n\x03\x04\x04\x01\x12\x03\
    I\x08\x13\n\x1b\n\x04\x04\x04\x02\0\x12\x03K\x08\x1b\x1a\x0e\x20service\
    \x20name\n\n\r\n\x05\x04\x04\x02\0\x04\x12\x04K\x08I\x15\n\x0c\n\x05\x04\
    \x04\x02\0\x05\x12\x03K\x08\x0e\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03K\
    \x0f\x16\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03K\x19\x1a\n%\n\x04\x04\x04\
    \x02\x01\x12\x03M\x08\x1b\x1a\x18\x20version\x20of\x20the\x20service\n\n\
    \r\n\x05\x04\x04\x02\x01\x04\x12\x04M\x08K\x1b\n\x0c\n\x05\x04\x04\x02\
    \x01\x05\x12\x03M\x08\x0e\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03M\x0f\
    \x16\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03M\x19\x1a\n\x1e\n\x04\x04\
    \x04\x02\x02\x12\x03O\x08\x18\x1a\x11\x20type\x20of\x20service\n\n\r\n\
    \x05\x04\x04\x02\x02\x04\x12\x04O\x08M\x1b\n\x0c\n\x05\x04\x04\x02\x02\
    \x05\x12\x03O\x08\x0e\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03O\x0f\x13\n\
    \x0c\n\x05\x04\x04\x02\x02\x03\x12\x03O\x16\x17\n'\n\x04\x04\x04\x02\x03\
    \x12\x03Q\x08\x1d\x1a\x1a\x20namespace\x20of\x20the\x20service\n\n\r\n\
    \x05\x04\x04\x02\x03\x04\x12\x04Q\x08O\x18\n\x0c\n\x05\x04\x04\x02\x03\
    \x05\x12\x03Q\x08\x0e\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03Q\x0f\x18\n\
    \x0c\n\x05\x04\x04\x02\x03\x03\x12\x03Q\x1b\x1c\n\n\n\x02\x04\x05\x12\
    \x04T\0V\x01\n\n\n\x03\x04\x05\x01\x12\x03T\x08\x13\n\x0b\n\x04\x04\x05\
    \x02\0\x12\x03U\x08\x20\n\r\n\x05\x04\x05\x02\0\x04\x12\x04U\x08T\x15\n\
    \x0c\n\x05\x04\x05\x02\0\x06\x12\x03U\x08\x13\n\x0c\n\x05\x04\x05\x02\0\
    \x01\x12\x03U\x14\x1b\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03U\x1e\x1f\n\n\
    \n\x02\x04\x06\x12\x04X\0Z\x01\n\n\n\x03\x04\x06\x01\x12\x03X\x08\x14\n\
    \x0b\n\x04\x04\x06\x02\0\x12\x03Y\x08&\n\x0c\n\x05\x04\x06\x02\0\x04\x12\
    \x03Y\x08\x10\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03Y\x11\x18\n\x0c\n\x05\
    \x04\x06\x02\0\x01\x12\x03Y\x19!\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03Y$\
    %\n\n\n\x02\x04\x07\x12\x04\\\0_\x01\n\n\n\x03\x04\x07\x01\x12\x03\\\x08\
    \x15\n'\n\x04\x04\x07\x02\0\x12\x03^\x08\x1d\x1a\x1a\x20namespace\x20of\
    \x20the\x20service\n\n\r\n\x05\x04\x07\x02\0\x04\x12\x04^\x08\\\x17\n\
    \x0c\n\x05\x04\x07\x02\0\x05\x12\x03^\x08\x0e\n\x0c\n\x05\x04\x07\x02\0\
    \x01\x12\x03^\x0f\x18\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03^\x1b\x1c\n\n\
    \n\x02\x04\x08\x12\x04a\0d\x01\n\n\n\x03\x04\x08\x01\x12\x03a\x08\x15\n\
    \x0b\n\x04\x04\x08\x02\0\x12\x03b\x08\x1c\n\r\n\x05\x04\x08\x02\0\x04\
    \x12\x04b\x08a\x17\n\x0c\n\x05\x04\x08\x02\0\x06\x12\x03b\x08\x0f\n\x0c\
    \n\x05\x04\x08\x02\0\x01\x12\x03b\x10\x17\n\x0c\n\x05\x04\x08\x02\0\x03\
    \x12\x03b\x1a\x1b\n\x0b\n\x04\x04\x08\x02\x01\x12\x03c\x08\"\n\r\n\x05\
    \x04\x08\x02\x01\x04\x12\x04c\x08b\x1c\n\x0c\n\x05\x04\x08\x02\x01\x06\
    \x12\x03c\x08\x15\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03c\x16\x1d\n\x0c\
    \n\x05\x04\x08\x02\x01\x03\x12\x03c\x20!\n\t\n\x02\x04\t\x12\x03f\0\x19\
    \n\n\n\x03\x04\t\x01\x12\x03f\x08\x16\n\n\n\x02\x04\n\x12\x04h\0m\x01\n\
    \n\n\x03\x04\n\x01\x12\x03h\x08\x15\n'\n\x04\x04\n\x02\0\x12\x03j\x08\
    \x1d\x1a\x1a\x20namespace\x20of\x20the\x20service\n\n\r\n\x05\x04\n\x02\
    \0\x04\x12\x04j\x08h\x17\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03j\x08\x0e\n\
    \x0c\n\x05\x04\n\x02\0\x01\x12\x03j\x0f\x18\n\x0c\n\x05\x04\n\x02\0\x03\
    \x12\x03j\x1b\x1c\n+\n\x04\x04\n\x02\x01\x12\x03l\x08\x1e\x1a\x1e\x20ent\
    rypoint\x20within\x20the\x20source\n\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\
    l\x08j\x1d\n\x0c\n\x05\x04\n\x02\x01\x05\x12\x03l\x08\x0e\n\x0c\n\x05\
    \x04\n\x02\x01\x01\x12\x03l\x0f\x19\n\x0c\n\x05\x04\n\x02\x01\x03\x12\
    \x03l\x1c\x1d\n\n\n\x02\x04\x0b\x12\x04o\0r\x01\n\n\n\x03\x04\x0b\x01\
    \x12\x03o\x08\x15\n\x0b\n\x04\x04\x0b\x02\0\x12\x03p\x08\x1c\n\r\n\x05\
    \x04\x0b\x02\0\x04\x12\x04p\x08o\x17\n\x0c\n\x05\x04\x0b\x02\0\x06\x12\
    \x03p\x08\x0f\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03p\x10\x17\n\x0c\n\x05\
    \x04\x0b\x02\0\x03\x12\x03p\x1a\x1b\n\x0b\n\x04\x04\x0b\x02\x01\x12\x03q\
    \x08\"\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04q\x08p\x1c\n\x0c\n\x05\x04\
    \x0b\x02\x01\x06\x12\x03q\x08\x15\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\
    \x03q\x16\x1d\n\x0c\n\x05\x04\x0b\x02\x01\x03\x12\x03q\x20!\n\t\n\x02\
    \x04\x0c\x12\x03t\0\x19\n\n\n\x03\x04\x0c\x01\x12\x03t\x08\x16\n\n\n\x02\
    \x04\r\x12\x04v\0y\x01\n\n\n\x03\x04\r\x01\x12\x03v\x08\x13\n'\n\x04\x04\
    \r\x02\0\x12\x03x\x08\x1d\x1a\x1a\x20namespace\x20of\x20the\x20service\n\
    \n\r\n\x05\x04\r\x02\0\x04\x12\x04x\x08v\x15\n\x0c\n\x05\x04\r\x02\0\x05\
    \x12\x03x\x08\x0e\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03x\x0f\x18\n\x0c\n\
    \x05\x04\r\x02\0\x03\x12\x03x\x1b\x1c\n\n\n\x02\x04\x0e\x12\x04{\0}\x01\
    \n\n\n\x03\x04\x0e\x01\x12\x03{\x08\x13\n\x0b\n\x04\x04\x0e\x02\0\x12\
    \x03|\x08\x20\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04|\x08{\x15\n\x0c\n\x05\
    \x04\x0e\x02\0\x06\x12\x03|\x08\x13\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\
    \x03|\x14\x1b\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\x03|\x1e\x1f\n\x0b\n\x02\
    \x04\x0f\x12\x05\x7f\0\x81\x01\x01\n\n\n\x03\x04\x0f\x01\x12\x03\x7f\x08\
    \x14\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\x80\x01\x08&\n\r\n\x05\x04\x0f\
    \x02\0\x04\x12\x04\x80\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\
    \x80\x01\x11\x18\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x80\x01\x19!\n\r\n\
    \x05\x04\x0f\x02\0\x03\x12\x04\x80\x01$%\n\x0c\n\x02\x04\x10\x12\x06\x83\
    \x01\0\x86\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\x83\x01\x08\x13\n(\n\
    \x04\x04\x10\x02\0\x12\x04\x85\x01\x08\x1d\x1a\x1a\x20namespace\x20of\
    \x20the\x20service\n\n\x0f\n\x05\x04\x10\x02\0\x04\x12\x06\x85\x01\x08\
    \x83\x01\x15\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\x85\x01\x08\x0e\n\r\n\
    \x05\x04\x10\x02\0\x01\x12\x04\x85\x01\x0f\x18\n\r\n\x05\x04\x10\x02\0\
    \x03\x12\x04\x85\x01\x1b\x1c\n\x0c\n\x02\x04\x11\x12\x06\x88\x01\0\x95\
    \x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\x88\x01\x08\x13\n+\n\x04\x04\
    \x11\x02\0\x12\x04\x8a\x01\x08\x1b\x1a\x1d\x20service\x20to\x20request\
    \x20logs\x20for\n\n\x0f\n\x05\x04\x11\x02\0\x04\x12\x06\x8a\x01\x08\x88\
    \x01\x14\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\x8a\x01\x08\x0e\n\r\n\x05\
    \x04\x11\x02\0\x01\x12\x04\x8a\x01\x0f\x16\n\r\n\x05\x04\x11\x02\0\x03\
    \x12\x04\x8a\x01\x19\x1a\n+\n\x04\x04\x11\x02\x01\x12\x04\x8c\x01\x08\
    \x18\x1a\x1d\x20stream\x20records\x20continuously\n\n\x0f\n\x05\x04\x11\
    \x02\x01\x04\x12\x06\x8c\x01\x08\x8a\x01\x1b\n\r\n\x05\x04\x11\x02\x01\
    \x05\x12\x04\x8c\x01\x08\x0c\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\x8c\
    \x01\r\x13\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\x8c\x01\x16\x17\n+\n\
    \x04\x04\x11\x02\x02\x12\x04\x8e\x01\x08\x18\x1a\x1d\x20count\x20of\x20r\
    ecords\x20to\x20request\n\n\x0f\n\x05\x04\x11\x02\x02\x04\x12\x06\x8e\
    \x01\x08\x8c\x01\x18\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\x8e\x01\x08\r\
    \n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\x8e\x01\x0e\x13\n\r\n\x05\x04\x11\
    \x02\x02\x03\x12\x04\x8e\x01\x16\x17\nZ\n\x04\x04\x11\x02\x03\x12\x04\
    \x92\x01\x08\x18\x1aL\x20relative\x20time\x20in\x20seconds\n\x20before\
    \x20the\x20current\x20time\n\x20from\x20which\x20to\x20show\x20logs\n\n\
    \x0f\n\x05\x04\x11\x02\x03\x04\x12\x06\x92\x01\x08\x8e\x01\x18\n\r\n\x05\
    \x04\x11\x02\x03\x05\x12\x04\x92\x01\x08\r\n\r\n\x05\x04\x11\x02\x03\x01\
    \x12\x04\x92\x01\x0e\x13\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\x92\x01\
    \x16\x17\n\x1e\n\x04\x04\x11\x02\x04\x12\x04\x94\x01\x08\x20\x1a\x10\x20\
    options\x20to\x20use\n\n\x0f\n\x05\x04\x11\x02\x04\x04\x12\x06\x94\x01\
    \x08\x92\x01\x18\n\r\n\x05\x04\x11\x02\x04\x06\x12\x04\x94\x01\x08\x13\n\
    \r\n\x05\x04\x11\x02\x04\x01\x12\x04\x94\x01\x14\x1b\n\r\n\x05\x04\x11\
    \x02\x04\x03\x12\x04\x94\x01\x1e\x1f\n\x0c\n\x02\x04\x12\x12\x06\x97\x01\
    \0\x9e\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\x97\x01\x08\x11\n'\n\x04\
    \x04\x12\x02\0\x12\x04\x99\x01\x08\x1c\x1a\x19\x20timestamp\x20of\x20log\
    \x20record\n\n\x0f\n\x05\x04\x12\x02\0\x04\x12\x06\x99\x01\x08\x97\x01\
    \x13\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\x99\x01\x08\r\n\r\n\x05\x04\x12\
    \x02\0\x01\x12\x04\x99\x01\x0e\x17\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\
    \x99\x01\x1a\x1b\n\x1f\n\x04\x04\x12\x02\x01\x12\x04\x9b\x01\x08(\x1a\
    \x11\x20record\x20metadata\n\n\x0f\n\x05\x04\x12\x02\x01\x04\x12\x06\x9b\
    \x01\x08\x99\x01\x1c\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\x9b\x01\x08\
    \x1a\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\x9b\x01\x1b#\n\r\n\x05\x04\
    \x12\x02\x01\x03\x12\x04\x9b\x01&'\n\x17\n\x04\x04\x12\x02\x02\x12\x04\
    \x9d\x01\x08\x1b\x1a\t\x20message\n\n\x0f\n\x05\x04\x12\x02\x02\x04\x12\
    \x06\x9d\x01\x08\x9b\x01(\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\x9d\x01\
    \x08\x0e\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\x9d\x01\x0f\x16\n\r\n\x05\
    \x04\x12\x02\x02\x03\x12\x04\x9d\x01\x19\x1a\n\x0c\n\x02\x04\x13\x12\x06\
    \xa0\x01\0\xa3\x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xa0\x01\x08\x1e\n\
    )\n\x04\x04\x13\x02\0\x12\x04\xa2\x01\x08\x1d\x1a\x1b\x20the\x20name\x20\
    of\x20the\x20namespace\n\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\xa2\x01\
    \x08\xa0\x01\x20\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xa2\x01\x08\x0e\n\r\
    \n\x05\x04\x13\x02\0\x01\x12\x04\xa2\x01\x0f\x18\n\r\n\x05\x04\x13\x02\0\
    \x03\x12\x04\xa2\x01\x1b\x1c\n\n\n\x02\x04\x14\x12\x04\xa5\x01\0\"\n\x0b\
    \n\x03\x04\x14\x01\x12\x04\xa5\x01\x08\x1f\n\x0c\n\x02\x04\x15\x12\x06\
    \xa7\x01\0\xaa\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xa7\x01\x08\x1e\n\
    )\n\x04\x04\x15\x02\0\x12\x04\xa9\x01\x08\x1d\x1a\x1b\x20the\x20name\x20\
    of\x20the\x20namespace\n\n\x0f\n\x05\x04\x15\x02\0\x04\x12\x06\xa9\x01\
    \x08\xa7\x01\x20\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xa9\x01\x08\x0e\n\r\
    \n\x05\x04\x15\x02\0\x01\x12\x04\xa9\x01\x0f\x18\n\r\n\x05\x04\x15\x02\0\
    \x03\x12\x04\xa9\x01\x1b\x1c\n\n\n\x02\x04\x16\x12\x04\xac\x01\0\"\n\x0b\
    \n\x03\x04\x16\x01\x12\x04\xac\x01\x08\x1f\n\x0c\n\x02\x04\x17\x12\x06\
    \xae\x01\0\xb1\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xae\x01\x08\x15\n\
    \x0c\n\x04\x04\x17\x02\0\x12\x04\xaf\x01\x08\x1c\n\x0f\n\x05\x04\x17\x02\
    \0\x04\x12\x06\xaf\x01\x08\xae\x01\x17\n\r\n\x05\x04\x17\x02\0\x06\x12\
    \x04\xaf\x01\x08\x0f\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xaf\x01\x10\x17\
    \n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xaf\x01\x1a\x1b\n\x0c\n\x04\x04\x17\
    \x02\x01\x12\x04\xb0\x01\x08\x17\n\x0f\n\x05\x04\x17\x02\x01\x04\x12\x06\
    \xb0\x01\x08\xaf\x01\x1c\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xb0\x01\
    \x08\r\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xb0\x01\x0e\x12\n\r\n\x05\
    \x04\x17\x02\x01\x03\x12\x04\xb0\x01\x15\x16\n\x0c\n\x02\x04\x18\x12\x06\
    \xb3\x01\0\xb5\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xb3\x01\x08\x16\n\
    \x0c\n\x04\x04\x18\x02\0\x12\x04\xb4\x01\x08\x16\n\x0f\n\x05\x04\x18\x02\
    \0\x04\x12\x06\xb4\x01\x08\xb3\x01\x18\n\r\n\x05\x04\x18\x02\0\x05\x12\
    \x04\xb4\x01\x08\x0e\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xb4\x01\x0f\x11\
    \n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xb4\x01\x14\x15\n\x0c\n\x02\x04\x19\
    \x12\x06\xb7\x01\0\xb9\x01\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xb7\x01\
    \x08\x19\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xb8\x01\x08\x17\n\x0f\n\x05\
    \x04\x19\x02\0\x04\x12\x06\xb8\x01\x08\xb7\x01\x1b\n\r\n\x05\x04\x19\x02\
    \0\x05\x12\x04\xb8\x01\x08\r\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xb8\x01\
    \x0e\x12\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xb8\x01\x15\x16b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
